Seguir os passos da descrição que dei no mail ao sanguino sobre a comunicação UDP

Ir ao codigo do waiting_for_list terminar a saida da rede quando nao deu para ligar a nenhum no JOIN_ID. Fazer também no stdin JOIN_LINK (sim)
Testar com um servidor de nos no netcat

Adicionar as verificações de todos os valores de saida do read

Adicionar a mudança para malloc

Corrigir o safeExit, para retornar tanto EXIT_FAILURE como EXIT_SUCCESS

DUVIDA - temos de fechar o fd UDP sempre que escrevemos/lemos? Nós deixamos o tipo ativo, com um servidor feito. É para mudar?

R: Sim

DUVIDA - JOIN_ID: a gente de momento escolhe um aleatoriamente, se esse falhar retira-o da lista e vai iterando desde o início tentando
todos até um dar, como eu descrevi no e-mail. Lembrei-me que posso enviar o UNREG do tipo que falhar a partir do tipo que se está a conectar também. Faço isso?

R: Não

DUVIDA - o professor é contra funçoes no main.c - Organização do programa em geral
nao

DUVIDA - aquelas coisas que eu me queixei na cache (aquelas copias desnecessarias)
R: nao mudar

DUVIDA - o fd do servidor TCP é para fechar quando não estamos ligados a nenhuma rede?
FUNCIONALIDADE EXTRA
-join servdown
-juntar a um elemento aleatorio da lista
-robustez do programa contra UDP (como falado no email)
-cache com numero aleatorio de objetos
-read com buffer "infinita" (ou possivelmente com um valor super elevado, que cresce dinamicamente até lá com memcpy e memset)
-Timer fantastico???

Reler tudo

A FAZER
breaks no main que deviam ser continue (caso contrário quebram o select) R: parece feito
leave passar a int para podermos chamar o safeExit se falhar o unreg
ler tudo, verificar saidas do readTCP
so ter o servidor TCP quando estamos ligados a uma rede, MAS antes disso testar com um servidor desligado de rede e ligarmo nos a ele
corrigir bug que apareceu e esta no outro ficheiro
ver porque é que nao acontece bug quando nunca estivemos ONENODE e se ligam a nos com o mesmo id
